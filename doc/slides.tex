\documentclass{beamer}
%\documentclass[handout]{beamer}

%\usepackage{beamerjcf}
\usepackage[latin1]{inputenc}

\definecolor{kwblue}{rgb}{0.67,0.12,0.92}
\definecolor{ceruleanblue}{rgb}{0, 0.48, 0.65}
\definecolor{lightpink}{rgb}{1., 0.71, 0.75}
\definecolor{lightblue}{rgb}{0.8,0.8,1}
\definecolor{lightred}{rgb}{1,0.8,0.8}

\let\emph\alert

\begin{document}

\title{Map/Reduce for the common man}
\author[Jean-Christophe]{Jean-Christophe Filli\^atre \& Kalyan Krishnamani}
\institute{
}
\date{ProVal, February 19, 2010}

\begin{frame}
  \titlepage
  \pgfimage[height=8mm]{cnrs-logo2}\hfill
  \pgfimage[height=6mm]{saclay}\hfill
  \pgfimage[height=10mm]{lrilogo}\hfill
  \pgfimage[height=8mm]{upsudlogo}
\end{frame}

\begin{frame}\frametitle{Overview}
  \begin{enumerate}
  \item Google's Map/Reduce
  \item Ocaml's Map/Reduce
  \item Implementation details
  \end{enumerate}
\end{frame}

\begin{frame}\frametitle{Google's Map/Reduce}
  what it is

  what it offers

  application domains

\end{frame}

\begin{frame}
  \begin{center}
    \hrulefill\\
    \emph{Ocaml's Map/Reduce}
  \end{center}
\end{frame}

\begin{frame}\frametitle{Two Ideas}
  \begin{enumerate}
  \item polymorphic map/fold instead of map/reduce

    \bigskip
  \item several library options
    \begin{itemize}
    \item sequential 
    \item several cores on the same machine
    \item network
    \end{itemize}
  \end{enumerate}
\end{frame}

\begin{frame}[fragile]\frametitle{API}
%\footnotesize
  \begin{itemize}
  \item traditional \texttt{List.map}
\begin{verbatim}
  val map : 
    f:('a -> 'b) -> 'a list -> 'b list
\end{verbatim}

    \bigskip
  \item traditional combination of \texttt{List.fold} and \texttt{List.map}
  
\begin{verbatim}
  val map_reduce :
    map:('a -> 'b) -> reduce:('c -> 'b -> 'c) -> 
    'c -> 'a list -> 'c
\end{verbatim}
    \begin{displaymath}
      \mathtt{map\_reduce}~f~g~c~l
      \begin{array}[t]{l}
        = \mathtt{fold}~g~c~(\mathtt{map}~f~l) \\
        = \mathtt{fold}~(\mathtt{fun}~c~x\rightarrow g~c~(f~x))~c~l\\
      \end{array}
    \end{displaymath}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]\frametitle{}
\begin{verbatim}
val map_reduce_ac :
  map:('a -> 'b) -> reduce:('b -> 'b -> 'b) -> 
  'b -> 'a list -> 'b
    
val map_reduce_a :
  map:('a -> 'b) -> reduce:('b -> 'b -> 'b) -> 
  'b -> 'a list -> 'b
\end{verbatim}
\end{frame}

\begin{frame}\frametitle{Options}
  \begin{center}
    \begin{tabular}{|c|c|c|c|c|c|}
      \hline
                 & \multicolumn{2}{|c|}{map} &
                 \multicolumn{3}{|c|}{map/reduce} \\\cline{2-6}
                 & map & local & remote & ac & a \\\hline\hline
      sequential & & & & & \\\hline
      cores      & & & & & \\\hline
      network    & & & & & \\\hline
    \end{tabular}
  \end{center}
\end{frame}


\begin{frame}\frametitle{}
  first demo
\end{frame}

\begin{frame}\frametitle{}
  detailed API
\end{frame}

\begin{frame}\frametitle{}
  another, more impressive demo ?
\end{frame}

\begin{frame}
  \begin{center}
    \hrulefill\\
    \emph{Implementation details}
  \end{center}
\end{frame}

\begin{frame}\frametitle{}
  common part between cores and network

  output/input\_value on core

  architecture-independent protocol for network

  same program for master and workers
\end{frame}



\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
