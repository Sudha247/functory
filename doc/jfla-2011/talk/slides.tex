\documentclass{beamer}
%\documentclass[handout]{beamer}

\usepackage[latin1]{inputenc}
%\usepackage[french]{babel}

\definecolor{kwblue}{rgb}{0.67,0.12,0.92}
\definecolor{ceruleanblue}{rgb}{0, 0.48, 0.65}
\definecolor{lightpink}{rgb}{1., 0.71, 0.75}
\definecolor{lightblue}{rgb}{0.8,0.8,1}
\definecolor{lightred}{rgb}{1,0.8,0.8}

\let\emph\alert

\begin{document}

\title{Functory : Une bibliothèque de calcul distribué \\ pour
  Objective Caml}
\author[Jean-Christophe]{Jean-Christophe Filli\^atre \& Kalyan Krishnamani}
\date{JFLA, 31 janvier 2011}

\begin{frame}
  \titlepage
  \pgfimage[height=8mm]{cnrs-logo2}\hfill
  \pgfimage[height=6mm]{saclay}\hfill
  \pgfimage[height=10mm]{lrilogo}\hfill
  \pgfimage[height=8mm]{upsudlogo}
\end{frame}

\begin{frame}\frametitle{}
  motivating example = SMT solvers on numerous VC during the night, 3
  machines, etc.
\end{frame}

\begin{frame}\frametitle{}
  requirements
  \begin{itemize}
  \item ocaml library
  \item fault tolerance
  \item user-friendly API
  \end{itemize}
\end{frame}

\begin{frame}\frametitle{}
  design a la Map/Reduce (1/2 slides)

  \begin{center}
    \includegraphics{master_workers_1.mps}
  \end{center}
\end{frame}

\begin{frame}\frametitle{}
  API main idea = compute function
\end{frame}

\begin{frame}\frametitle{}
  simpler situations $=>$ simpler implementations but same API

  sequential
  cores
\end{frame}

\begin{frame}\frametitle{}
  network and marshaling considerations

  if both programs are the same, API is unchanged
\end{frame}

\begin{frame}\frametitle{}
  but sometimes you can't afford running the same program as master
  and workers $=>$ not more marshaling of closures $=>$ slightly different API
\end{frame}

\begin{frame}\frametitle{}
  derived API

  (mention that details are in the paper)
\end{frame}

\begin{frame}\frametitle{}
  implementation details

  first, cores, reusing the picture to explain that workers are simply
  forks (no control over scheduling)
  \begin{center}
    \includegraphics{master_workers_1.mps}
  \end{center}

  explain the main loop with pending tasks and associated data structure
\end{frame}

\begin{frame}\frametitle{}
  network implementation

  first, communication model (client/server, TCP/IP, etc.), reusing
  the picture 
  \begin{center}
    \includegraphics{master_workers_network.mps}
  \end{center}
\end{frame}

\begin{frame}\frametitle{Protocol}
  \only<1>{master sends a task to a worker}
  \only<2>{worker computes and sends back a result}
  \only<3-4>{worker and workers exchange \emph{ping}/\emph{pong} messages}
  \only<5>{in case of a disconnection...}
  \only<6>{the task is \emph{rescheduled} to another worker}
  \only<7>{whenever one completes...}
  \only<8>{the other one is stopped}
  \only<9>{the master is notified when a computation fails}
  \only<10>{at the very end, the master may ask the workers to stop}
  \vfill
  \begin{center}
    \only<1>{\includegraphics{master_workers_assign.mps}}
    \only<2>{\includegraphics{master_workers_completed.mps}}
    \only<3>{\includegraphics{master_workers_ping.mps}}
    \only<4>{\includegraphics{master_workers_pong.mps}}
    \only<5>{\includegraphics{master_workers_disconnection.mps}}
    \only<6>{\includegraphics{master_workers_assign_2.mps}}
    \only<7>{\includegraphics{master_workers_completed_2.mps}}
    \only<8>{\includegraphics{master_workers_kill.mps}}
    \only<9>{\includegraphics{master_workers_aborted.mps}}
    \only<10>{\includegraphics{master_workers_stop.mps}}
  \end{center}
\end{frame}

\begin{frame}\frametitle{}
  fault tolerance, protocol

  \begin{center}
    \includegraphics{state.mps}
  \end{center}
\end{frame}

\begin{frame}\frametitle{}
  benchmarks

  SMT solvers first
\end{frame}

\begin{frame}\frametitle{}
  n-queens
\end{frame}

\begin{frame}\frametitle{}
  Mandelbrot
\end{frame}

\begin{frame}\frametitle{}
  matrix multiplication
\end{frame}

\begin{frame}\frametitle{}
  conclusion, future work, etc.
\end{frame}


\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 

